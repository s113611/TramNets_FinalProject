NET
scheme TIMETABLE = extend NET with
class
  type
    TimeTable = TramId -m-> Plan, -- time tables
    Plan = (StopId >< Time >< Time) -list,
    -- data type for easily returning a line in a plan
    SubPlan = (StopId >< Time >< Time),
    SubPlanPair = (SubPlan >< SubPlan),
    TramId = Text -- tram names
    value /* generators */
      -- the empty timetable
      empty: TimeTable = [],

      -- add to a time table an empty plan for a new tram
      addTram: TramId >< TimeTable -> TimeTable
      addTram(trid,t) is t !! [trid +> <..>],

      -- add a stop with arrival time and departure time to the plan for a given tram
      addStop: TramId >< StopId >< Time >< Time >< TimeTable -> TimeTable
      addStop(trid,stid,time1,time2,t) is 
      		let 
    			pla = t(trid),--get current plan with tramId
    			addPl = pla ^ <.(stid,time1,time2).> -- add new stop to plan
    		in
    			t !! [trid +> addPl] -- update the timetable
    		end
  value /* observers */
     -- check whether a tram with a given name exists in a given time table
     isIn : TramId >< TimeTable -> Bool
     isIn(tid,t) is tid isin dom t,

     -- you can add more observers here
     -- check whether the plan is vaild for one specific tram
     isValidPlan: Plan >< Net-> Bool
     isValidPlan(plan,n) is 
     	let
     		firstStop = hd plan, -- get the first stop of the plan
      		secondStop = hd (tl plan),-- get the second stop of the plan
      		(sid,arrTimeA,departTimeA) = firstStop,
      		(sid2,arrTimeB,departTimeB) = secondStop
     	in
     		if(isIn(sid,n) /\ isIn(sid2,n)) then -- check do the stops in the Net
     				--check whether the two stops directly connected, 
      				--and(arriveTime of stop2 - departureTime of stop1) should be larger than the minimum driving time between these two stops.
      			if (areDirectlyConnected(sid,sid2,n))/\(arrTimeB-departTimeA) > minDrivingTime(sid,sid2,n) then 	
      			--if the first two stops are valiad, then check the tail of the plan, until only one stop left
      				if(len(tl plan) >=2) then
      					isValidPlan(tl plan, n)
      				else true end
      		    else false end
      		else false end
     	end,
     
     --compare the arrive time for a stop
     -- if the period between two arrive times is smaller than 2, then they are at the same stop
     checkIsAtSameStopAtSameTime: Time >< Time -> Bool
     checkIsAtSameStopAtSameTime(t1,t2) is t1-t2 <= 2 \/ t2-t1 <= 2,
     
     
	-- Retrieves a list of pairs in the plan
	retrievePairCombination: Plan >< (SubPlanPair)-list -> (SubPlanPair)-list
	retrievePairCombination(plan,pairCombo) is
		 let
		 	head = hd plan,
		 	headOfTail = hd tl plan,
		 	pairCombo = pairCombo ^ <.(head, headOfTail).>,
		 	plan = tl plan
		 in	
		 	if(len plan = 1) then
		 		pairCombo
		 	else
		 		retrievePairCombination(plan,pairCombo)
		 	end
		 end
	pre plan ~=<..>,
	
	-- comparing pairs : returns true if they are overlapping time wise
	arePairConflicting: SubPlanPair >< SubPlanPair >< Net -> Bool
	arePairConflicting((SubPlan1,SubPlan2),(SubPlan3,SubPlan4),net) is 
		let
			(SID1,arr1,dep1) = SubPlan1,
			(SID2,arr2,dep2) = SubPlan2,
			(SID3,arr3,dep3) = SubPlan3,
			(SID4,arr4,dep4) = SubPlan4,
			drivingTime = minDrivingTime(SID1,SID2,net)
		in
			-- if the pair have the same stopId relation
			(SID1 = SID3) /\ (SID2 = SID4) 
			/\
			-- if the times slots overlap
			((arr2 - arr4 <= drivingTime /\ arr2 - arr4 >= 0)
				\/
			(arr4 - arr2 <= drivingTime /\ arr4 - arr2 >= 0))
		end,
	
	-- detectConnectionOverflow
	detectConnectionOverflow: TimeTable >< Net -> Bool
	detectConnectionOverflow(timeTable,net) is 
	let 
		planSet = rng(timeTable)
	in
		(all plan : Plan :- plan isin planSet =>
			let
				pairCombinationList = retrievePairCombination(plan,<..>)
			in
				(all subPlanPair : SubPlanPair :- subPlanPair isin pairCombinationList =>
					comparePairWithAllOtherPlans(subPlanPair,plan,timeTable,net)
				)
			end
		)
	end,
	
	-- compare pair with all other plans DOES NOT WORK!!!!!
	comparePairWithAllOtherPlans: SubPlanPair >< Plan >< TimeTable >< Net -> Bool
	comparePairWithAllOtherPlans(subPlanPair,plan,timeTable,net) is 
		let
			((SID1,arr1,dep1),(SID2,arr2,dep2)) = subPlanPair,
			capacityOfConnection = connectedCapacity(SID1,SID2,net)
		in
			(all plan2 : Plan :- plan2 isin rng(timeTable) /\ plan ~= plan2 =>
				let
					pairComboList = retrievePairCombination(plan2,<..>),
					pairPlanGood = (all subPlanPair2 : SubPlanPair :- subPlanPair2 isin pairComboList => 
						~arePairConflicting(subPlanPair,subPlanPair2,net))
				in
					true
				end
			)
		end
  value /* predicates to check time tables */   
  
  	  -- Do we need to check the capacity of each stop
      isWellformed : TimeTable >< Net -> Bool
      isWellformed(t, n) is 
      	(all trId : TramId :- trId isin dom t=>
      		let
      			plan = t(trId), -- get plan of the tram
      			--index =1,
      			--firstStop = plan(index), -- get the first stop of the plan
      			--secondStop = hd (tl plan),-- get the second stop of the plan
      			--(sid,arrTimeA,departTimeA) = firstStop,
      			--(sid2,arrTimeB,departTimeB) = secondStop,
      			newPlan = tl plan
      		in
      			if(len(plan) ~= 1) then
      				if(isValidPlan(plan,n)) then
      					isWellformed(t !! [trId +> newPlan],n) 
      				else false end
      			else true end /\
      			-- check  capacity for each directions
      			(true)
      			
      		end)
end  
