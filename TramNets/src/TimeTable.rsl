NET
scheme TIMETABLE = extend NET with
class
  type
    TimeTable = TramId -m-> Plan, -- time tables
    Plan = (SubPlan) -list,
    -- data type for easily returning a line in a plan
    SubPlan = (StopId >< Time >< Time),
    SubPlanPair = (SubPlan >< SubPlan),
    TramId = Text, -- tram names,
    Count = Nat

    value /* generators */
      -- the empty timetable
      empty: TimeTable = [],

      -- add to a time table an empty plan for a new tram
      addTram: TramId >< TimeTable -> TimeTable
      addTram(trid,t) is t !! [trid +> <..>],

      -- add a stop with arrival time and departure time to the plan for a given tram
      addStop: TramId >< StopId >< Time >< Time >< TimeTable -> TimeTable
      addStop(trid,stid,time1,time2,t) is 
      		let 
    			pla = t(trid),--get current plan with tramId
    			addPl = pla ^ <.(stid,time1,time2).> -- add new stop to plan
    		in
    			t !! [trid +> addPl] -- update the timetable
    		end
  value /* observers */
     -- check whether a tram with a given name exists in a given time table
     isIn : TramId >< TimeTable -> Bool
     isIn(tid,t) is tid isin dom t,

	------------------------Check valid plan part--------------------------------------
     -- you can add more observers here
     -- check whether the plan is vaild for one specific tram
     isValidPlan: Plan >< Net-> Bool
     isValidPlan(plan,n) is 
     	let
     		firstStop = hd plan, -- get the first stop of the plan
      		secondStop = hd (tl plan),-- get the second stop of the plan
      		(sid,arrTimeA,departTimeA) = firstStop,
      		(sid2,arrTimeB,departTimeB) = secondStop
     	in
     		if(isIn(sid,n) /\ isIn(sid2,n)) then -- check do the stops in the Net
     				--check whether the two stops directly connected, 
      				--and(arriveTime of stop2 - departureTime of stop1) should be larger than the minimum driving time between these two stops.
      			if (areDirectlyConnected(sid,sid2,n))/\(arrTimeB-departTimeA) >= minDrivingTime(sid,sid2,n) then 	
      			--if the first two stops are valiad, then check the tail of the plan, until only one stop left
      				if(len(tl plan) >=2) then
      					isValidPlan(tl plan, n)
      				else true end
      		    else false end
      		else false end
     	end,
     
     -- check whether a plan-set is a valid plan set	
     checkIsValidPlanSet: Plan-set >< Net -> Bool
     checkIsValidPlanSet(pSet,n) is
     	let
     		first = hd pSet,
     		newSet = pSet\{first}
     	in
     		if(isValidPlan(first,n)) then
     			if(card(newSet)>0) then
     					checkIsValidPlanSet(newSet,n)
     			else true end
     		else false end
     	end,
     	
     -- check the validation of all the plans in timetable[Main function]
     checkIsValidPlanForEachTram: TimeTable >< Net -> Bool
     checkIsValidPlanForEachTram(t,n) is
         let
         	planSet = rng(t)
         in
         	checkIsValidPlanSet(planSet,n)
         end, 
         
------------------------Check Stop capacity functions part--------------------------------------
     --compare the arrive time for a stop
     -- if the period between two arrive times is smaller than 2, then they are at the same stop
     checkIsAtSameStopAtSameTime: Time >< Time -> Bool
     checkIsAtSameStopAtSameTime(t1,t2) is (t1-t2 <= 2 /\ t1-t2 >=0) \/ (t2-t1 <= 2 /\ t2-t1 >=0),
     
      --get the same stops information in one plan with the stopId
     getSameStopsFromOnePlan: StopId >< Plan -> SubPlan-set
     getSameStopsFromOnePlan(sid,p) is
     	{(sid1,arrT,depaT) | (sid1,arrT,depaT): SubPlan :- (sid1,arrT,depaT) isin p /\ sid1 = sid},
     	
     -- Compare one subplan with a subplan set, which would generated by getSameStopsFromOnePlan() from other timetable	
     -- return the total count of the same trams	
     compareSubPlanTime: SubPlan >< SubPlan-set >< Count -> Count
     compareSubPlanTime(subP,pSet,count) is
		let
			(sid,arrTime,departTime) = subP,
			(sid1,arrTime1,departTime1) = hd pSet
		in
			if(checkIsAtSameStopAtSameTime(arrTime,arrTime1)) then
				let
					count = count +1
				in
					if(card(pSet\{(sid1,arrTime1,departTime1)}) >=1) then 
						compareSubPlanTime(subP,pSet\{(sid1,arrTime1,departTime1)},count)
					else count end
				end
			else
				if(card(pSet\{(sid1,arrTime1,departTime1)}) >=1) then 
					compareSubPlanTime(subP,pSet\{(sid1,arrTime1,departTime1)},count)
				else count end
			end
  		end,
  		
  	-- compare one stop with a plan from other tram
  	compareOneSubWithOnePlan: SubPlan >< Plan ->  Count
  	compareOneSubWithOnePlan(subP,plan) is
  		let
  			(sid,arrT,departT) = subP,
  			subPlanSet = getSameStopsFromOnePlan(sid,plan),
  			count = 0
  		in
  			if(card(subPlanSet) > 1) then
  				compareSubPlanTime(subP,subPlanSet,count)
  			else count end
  		end,
  	
  	--compare one stop with whole timetable
  	compareOneSubWithAllPlans: SubPlan >< Plan-set >< Count -> Count
  	compareOneSubWithAllPlans(subP,planSet,count) is
  		if(card(planSet) >= 1) then
  			let
  				--planSet = getAllObjects(t),
  				plan = hd planSet,
  				count = compareOneSubWithOnePlan(subP,plan) + count,
  				newPlan = planSet\{plan}
  			in
  				if(card(newPlan) >=1) then
  					compareOneSubWithAllPlans(subP,newPlan,count)
  				else count end
  			end
  		else count end,
  	
  	--compare one stop with whole timetable
  	compareOneSubWithTimeTable: SubPlan >< TimeTable >< Count -> Count
  	compareOneSubWithTimeTable(subP,t,count) is
  		let
  			planSet = rng(t)
  		in
  			compareOneSubWithAllPlans(subP,planSet,count)
  		end,
  	
  	-- compare one tram plan with all the other tram's plan
  	checkStopCapacity: Plan >< TimeTable >< Net -> Bool
  	checkStopCapacity(plan,t,n) is
  		if(len(plan) ~= 0) then
			let
  				firstSubplan = hd plan,
  				nextplan = tl plan,
  				(sid,arrT,departT) = firstSubplan,
  				capa = capacity(sid,n)
  			in
 				if(compareOneSubWithTimeTable(firstSubplan,t,0) <= capa) then
 					checkStopCapacity(nextplan, t, n)
 				else false end
  			end
  		else true end,
  		
  	-- check all the stops capacities[Main function]
  	-- Idea is : get one random plan of tram from timetable, compare it with all the other tram plans
  	checkAllStopsCapacities: TimeTable >< Net -> Bool
  	checkAllStopsCapacities(t,n) is
  		let
  			allPlans = rng(t)
  		in
  			(all plan: Plan:- plan isin allPlans =>
  				checkStopCapacity(plan,t,n)
  			)
  		end,
     
    -----------------------------------------Check connections capacity functions part------------------------------ 
	-- The overall idea is : For each subPlan-pair we compare all other subplanPairs in all other plans. 
	-- for each match, we increment a counter and at last we compare with the max capacity of the connection
	
	-- Retrieves a list of pairs in the plan e.g. ((("A",0,1 ),("B",10,14)))
	retrievePairCombination: Plan >< (SubPlanPair)-list -> (SubPlanPair)-list
	retrievePairCombination(plan,pairCombo) is
		 let
		 	head = hd plan,
		 	headOfTail = hd tl plan,
		 	pairCombo = pairCombo ^ <.(head, headOfTail).>,
		 	plan = tl plan
		 in	
		 	if(len plan = 1) then
		 		pairCombo
		 	else
		 		retrievePairCombination(plan,pairCombo)
		 	end
		 end,
	
	-- comparing pairs : Returns true if they are overlapping time wise
	arePairConflicting: SubPlanPair >< SubPlanPair >< Net -> Bool
	arePairConflicting((SubPlan1,SubPlan2),(SubPlan3,SubPlan4),net) is 
		let
			(SID1,arr1,dep1) = SubPlan1,
			(SID2,arr2,dep2) = SubPlan2,
			(SID3,arr3,dep3) = SubPlan3,
			(SID4,arr4,dep4) = SubPlan4,
			drivingTime = minDrivingTime(SID1,SID2,net)
		in
			-- if the pair have the same stopId relation
			(SID1 = SID3) /\ (SID2 = SID4) 
			/\
			-- if the times slots overlap
			((arr2 - arr4 <= drivingTime /\ arr2 - arr4 >= 0)
				\/
			(arr4 - arr2 >= drivingTime /\ arr4 - arr2 <= 0))
		end,
	
	-- DetectConnectionOverflow (main function)
	detectConnectionOverflow: TimeTable >< Net -> Bool
	detectConnectionOverflow(timeTable,net) is 
	let 
		planSet = rng(timeTable)
	in
		(all plan : Plan :- plan isin planSet =>
			let
				pairCombinationList = retrievePairCombination(plan,<..>)
			in
				(all subPlanPair : SubPlanPair :- subPlanPair isin pairCombinationList =>
					let
						((SID1,arr1,dep1),(SID2,arr2,dep2)) = subPlanPair,
						capacityOfConnection = connectedCapacity(SID1,SID2,net)
					in
						if(comparePairWithAllOtherPlans(subPlanPair,plan,planSet,net,0) > capacityOfConnection)
						\/ comparePairWithAllOtherPlansHeadWay(subPlanPair,plan,planSet,net) then
							false
						else
							true
						end
					end)
			end)
	end,
	
	-- We compare a subplanpair with all other plans.
	comparePairWithAllOtherPlans: SubPlanPair >< Plan >< Plan-set >< Net >< Nat -> Nat
	comparePairWithAllOtherPlans(subPlanPair,plan,planSet,net,counter) is 
	if(card planSet >= 1) then
		let
			currentPlan = hd planSet
		in
			if(currentPlan = plan \/ comparePairWithOnePlan(subPlanPair,currentPlan,net)) then
				comparePairWithAllOtherPlans(subPlanPair,plan,planSet \ {currentPlan},net,counter+1)
			else
				comparePairWithAllOtherPlans(subPlanPair,plan,planSet \ {currentPlan},net,counter)
			end
		end
	else
		counter
	end,
	
	-- We compare one subplanpair with one single plan	
	comparePairWithOnePlan: SubPlanPair >< Plan >< Net -> Bool
	comparePairWithOnePlan(subPlanPair,plan,net) is 
		let 
			pairComboList = retrievePairCombination(plan,<..>),
			pairPlanConflicting = (exists subPlanPair2 : SubPlanPair :- subPlanPair2 isin pairComboList /\ 
						arePairConflicting(subPlanPair,subPlanPair2,net))
		in
			pairPlanConflicting
		end,
	-----------------------------------------Check that headway is withheld------------------------------------------
	arePairConflictingHeadway: SubPlanPair >< SubPlanPair >< Net -> Bool
	arePairConflictingHeadway((SubPlan1,SubPlan2),(SubPlan3,SubPlan4),net) is 
	let
		(SID1,arr1,dep1) = SubPlan1,
		(SID2,arr2,dep2) = SubPlan2,
		(SID3,arr3,dep3) = SubPlan3,
		(SID4,arr4,dep4) = SubPlan4,
		minHeadWay = minHeadway(SID1,SID2,net)
	in
		-- if the pair have the same stopId relation
		(SID1 = SID3) /\ (SID2 = SID4) 
		/\
		-- if the time slots overlap (dep)
		((dep1 - dep3 <= minHeadWay /\ dep1 - dep3 >= 0)
			\/
		(dep3 - dep1 <= minHeadWay /\ dep3 - dep1 >= 0))
		\/
		-- if the time slots overlap (arr)
		((arr2 - arr4 <= minHeadWay /\ arr2 - arr4 >= 0)
			\/
		(arr4 - arr2 <= minHeadWay /\ arr4 - arr2 >= 0)	
		)
	end,
		
	-- We compare one subplanpair with one single plan	
	comparePairWithOnePlanHeadway: SubPlanPair >< Plan >< Net -> Bool
	comparePairWithOnePlanHeadway(subPlanPair,plan,net) is 
		let 
			pairComboList = retrievePairCombination(plan,<..>),
			pairPlanConflicting = (exists subPlanPair2 : SubPlanPair :- subPlanPair2 isin pairComboList /\ 
						arePairConflictingHeadway(subPlanPair,subPlanPair2,net))
		in
			pairPlanConflicting
		end,
		
	-- We compare a subplanpair with all other plans.
	comparePairWithAllOtherPlansHeadWay: SubPlanPair >< Plan >< Plan-set >< Net -> Bool
	comparePairWithAllOtherPlansHeadWay(subPlanPair,plan,planSet,net) is 
		(exists plan2 : Plan :- plan2 isin planSet /\ plan2 ~= plan /\
			comparePairWithOnePlanHeadway(subPlanPair,plan2,net))

	
  value /* predicates to check time tables */   
      isWellformed : TimeTable >< Net -> Bool
      isWellformed(t, n) is
        	-- check is it valid plan for each tram
      		checkIsValidPlanForEachTram(t,n) /\ 
      		--check capacity of all stops
      		checkAllStopsCapacities(t,n) /\
      		--check capacity and headway of each connection
      		detectConnectionOverflow(t,n)
end  
