scheme NET =
class
  type
  	-- not sure if this is the right way to represent ?? 
    Net = StopId -m-> (Capacity >< Connection-set), -- tram nets
    mapValues = (Capacity >< Connection-set),
    Headway = Time, -- minimum headways
    DrivingTime = Time, -- minimum driving times
    Time = Nat, -- times in number of minutes
    Capacity = Nat, -- capacities
    StopId = Text,  -- names of stops
    Stop = (StopId >< Capacity), -- A stop
    ConnectionInformation = (Capacity >< DrivingTime >< Headway), -- basic connection information
    Connection = StopId >< StopId >< ConnectionInformation
    
  value /* generators */
    empty :  Net = [],  -- the empty net

    -- insert a stop with a given name and capacity 
    insertStop : StopId >< Capacity >< Net -> Net
    insertStop(SID, Cap, n) is n !! [ SID +> (Cap,{})],
	
    -- add a connection between given stops, 
    -- with the given capacity, minimum driving time and minimum headway
    addConnection : StopId >< StopId  >< Headway >< Capacity >< DrivingTime >< Net -> Net
    addConnection(SID, SID2,HWay,Cap,DTime,Net) is 
    	if(isIn(SID,Net) /\ isIn(SID2,Net)) then -- Make sure the stops have already exsited.
    		let
    			(capA,connectA) = Net(SID),
    			(capB,connectB) = Net(SID2)
    		in
    			let
    				newConnectA = connectA union {(SID,SID2,(Cap,DTime,HWay))},
    				newConnectB = connectB union {(SID,SID2,(Cap,DTime,HWay))}
    			in
    				Net !! [SID +> (capA,newConnectA)] !! [SID2 +> (capB,newConnectB)]
    			end
    		end
    	else Net end
    	
  value /* observers */
    -- check whether a stop is in a network     
    isIn : StopId >< Net -> Bool
    isIn(SID,Net) is SID isin dom Net,
 
    -- check whether two stops are directly connected in a network        
    areDirectlyConnected : StopId >< StopId >< Net -> Bool
   	areDirectlyConnected(SID,SID2,n) is 
   		let
   			(capA,connectA) = n(SID)
   		in
   			(exists (SID3,SID4,connectInfo): Connection :- (SID3,SID4,connectInfo) isin connectA /\ areEqual(SID,SID2,SID3,SID4))
   		end
   	pre isWellformed(n),
   	
   	-- support function
   	areEqual : StopId >< StopId >< StopId >< StopId -> Bool
   	areEqual(SID1,SID2,SID3,SID4) is SID1 = SID3 /\ SID2 = SID4 \/ SID1 = SID4 /\ SID2 = SID3,
   	
    -- get minimum head way between two connected stops        
   	minHeadway : StopId >< StopId >< Net -~-> Headway
    minHeadway(SID,SID2,Net) is 
    	let
    		(capA,connectA) = Net(SID),
    		(capB,connectB) = Net(SID2)
    	in
    		if(areDirectlyConnected(SID,SID2,Net)) then
    			let
    				--(SID,SID2,(Cap,DTime,HWay)) = connectA
    				HWay = 0
    			in
    				if(exists (SID,SID2,(Cap,DTime,HWay)): Connection :- (SID,SID2,(Cap,DTime,HWay)) isin connectB) then
    					HWay
    				else 0 end
    			end
    		else
    			0
    		end
    	end,

   -- get minimum driving time between two connected stops        
   -- minDrivingTime : StopId >< StopId >< Net -~-> DrivingTime
  --  ..., 

    -- get the capacity for a connection between two connected stops
  --  capacity : StopId >< StopId >< Net -~-> Capacity
 --   ...,
 
    -- get the capacity of a stop 
 	capacity : StopId >< Net -~-> Capacity
  	capacity(SID,n) is 
  		let
  			(cap,connSet) = n(SID)
  		in
  			cap
  		end
  		
 value /* predicates to check nets */
   isWellformed : Net -> Bool
   isWellformed(n) is n ~= [] /\ -- we check that the map is not empty
   			(all SID : StopId :- SID isin n => 
   				(n(SID) ~= (0,{})) --no stop should contain empty connection-list or have a capacity of 0 (defeats the purpose)
   			/\
   			(let  -- There should not exists two connections in a connection-list where the stops are identical
   				(capA,connectA) = n(SID)
   			 in
   				(all (sid1,sid2,connInfo) : Connection :- (sid1,sid2,connInfo) isin connectA => 
   					(all (sid3,sid4,connInfo2) : Connection :- (sid3,sid4,connInfo2) isin connectA /\
   						 (sid3,sid4,connInfo2) ~= (sid1,sid2,connInfo) => ~areEqual(sid1,sid2,sid3,sid4)))
   			end)
   			)
end  
